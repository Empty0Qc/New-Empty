//////https://www.nowcoder.com/practice/97ba57c35e9f4749826dc3befaeae109?tpId=37&tqId=21300&tPage=1&rp=&ru=/ta/huawei&qru=/ta/huawei/question-ranking
////
//////#include <iostream>
//////#include <string>
//////#include <set>
//////#include <queue>
//////#include <algorithm>
//////using namespace std;
//////
//////
//////
//////int main()
//////{
//////	int n;
//////	while (cin >> n)
//////	{
//////	}
//////	return 0;
//////}
////
//////2282
////#include<iostream>
////#include<vector>
////#include<string.h>
////using namespace std;
////
////int stack_temp[9] = { 0 };
////
////// whether arr of n-length can be generated by input data raw, by an stack operation(FILO)
////bool is_generate_by_stack(int *str, int *raw, int n)
////{
////	int top = 0;
////	int raw_index = 0;
////	//for(int i = 0; i < n; i++){
////	int i = 0;
////	while (1){
////		if (i == n)
////			return true;
////
////		while (top>0 && i<n && str[i] == stack_temp[top - 1]){
////			top--;
////			i++;
////		}
////
////		//end
////		if ((raw_index == n) && (i != n))
////		{
////			return false;
////		}
////
////		while (i<n && raw_index < n){
////			stack_temp[top++] = raw[raw_index++];
////			if (str[i] == raw[raw_index - 1])
////			{
////				//i++; raw_index++;
////				//or
////
////				break;
////			}
////		}
////
////		/*      if(str[i] == raw[raw_index]){
////		i++;
////		raw_index++;
////		}
////		*/
////		//end status
////
////
////
////		/*
////		while((top>0) && (str[i] == stack_temp[top-1]){
////		top--;
////		continue;
////		}
////
////		while(str[i] != raw[i]){
////		stack_temp[top++] = raw[i];
////		}*/
////	}
////	return true;
////}
////
////void print(int layer, int *arr, int * str, int n, int * raw)
////{
////	//bottom
////	if (layer == n){
////		for (int i = 0; i<n; i++){
////			if (arr[i] != 0)
////			{
////				str[layer - 1] = arr[i];
////				if (is_generate_by_stack(str, raw, n) == true){
////					int ii = 0;
////					for (ii = 0; ii < n - 1; ii++){
////						cout << str[ii] << ' ';
////					}
////					cout << str[ii] << endl;
////				}
////			}
////		}
////	}
////	else{
////		for (int i = 0; i < n; i++){
////			if (arr[i] != 0){
////				int temp = arr[i];
////				//str[2*layer-2] = arr[i];
////				//str[2*layer-1] = ' ';
////				str[layer - 1] = arr[i];
////				arr[i] = 0;
////				print(layer + 1, arr, str, n, raw);
////				arr[i] = temp;
////			}
////		}
////	}
////
////}
////
////
////int main()
////{
////	int n, temp;
////	//int *arr = new int[n];
////	//int *raw = new int[n];
////	//int *str= new int[n];        delete []str; !!!
////	int arr[10] = { 0 };
////	int raw[10] = { 0 };
////	int str[10] = { 0 };
////
////	//  while(1){
////	cin >> n;
////	//if(n<1 || n>9)break;
////
////	memset(str, 0, sizeof(int)*n);
////
////	for (int i = 0; i<n; i++){
////		cin >> arr[i];
////		raw[i] = arr[i];
////	}
////
////	//sort
////	for (int i = 1; i<n; i++)
////	{
////		temp = arr[i];
////		for (int j = i - 1; j >= 0; j--){
////			if (arr[j] > temp){
////				arr[j + 1] = arr[j];
////				arr[j] = temp;
////			}
////		}
////	}
////
////	print(1, arr, str, n, raw);
////
////	//    }
////	//cin >> n;
////	return 0;
////}
//
//#include <iostream>
//#include <vector>
//#include <stack>
//#include <algorithm>
//using namespace std;
//
////is_order函数用来判断当前排序即v1数组是否可以通过数组v压栈得出
//bool is_order(vector<int> &v, vector<int> &v1, int n)
//{
//	if (v.size() == 0 || v1.size() == 0 || n <= 0)
//		return false;
//	stack<int> s;
//	int j = 0;
//	for (size_t i = 0; i < v.size(); i++)
//	{
//		s.push(v[i]);
//		while (j < n && s.size() != 0 && v1[j] == s.top())
//		{
//			s.pop();
//			j++;
//		}
//	}
//	return s.empty();
//}
//int main()
//{
//	int n;
//	while (cin >> n)
//	{
//		vector<int> v(n),v1(n);
//		for (int i = 0; i < n;i++)
//			cin >> v[i];
//		//把输入的数据数组复制一份到v1
//		v1.assign(v.begin(),v.end());
//		//对v1进行排序 ----------由题目输出要以字典序排序输出可知
//		sort(v1.begin(), v1.end());
//		do
//		{
//			if (is_order(v, v1, n))
//			{
//				for (auto e : v1)
//					cout << e << " ";
//				cout << endl;
//			}
//		} while (next_permutation(v1.begin(), v1.end()));
//	}
//	return 0;
//}